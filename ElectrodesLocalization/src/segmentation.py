from sklearn.cluster import KMeans, SpectralClustering
import numpy as np
from numpy.linalg import norm
from utils import Electrode
from typing import List
from sklearn.linear_model import LinearRegression

def __flip_positive_x(a: np.ndarray) -> np.ndarray:
    """In a list of vectors, flips each vector if necessary, so that its
    x-component is positive.
    
    Input:
    - a: an array of shape (M, N) that contains M vectors of N components each.
    
    - output: an array of shape (M, N) where each vector a[i] has been flipped
    (or not) such that output[i, 0] is positive. All vectors a[i] and a[j] are
    treated indepedently from each other."""
    return np.where(a[:,0:1] >= 0, a, -a)

def __get_vector_K_nearest(contacts: np.ndarray, k:int) -> List[np.ndarray]:
    """Returns the vector between each contact and its K closest neighbors.

    Input:
    - contacts: an array of shape (N, 3) that contains the coordinates of the input
    - k: the number of neighbors to include

    Output:
    - neighbors: an array of shape (K, N, 3) that contains the absolute
    coordinates of the K closest neighbors.
    - vectors: an array of shape (K, N, 3) that contains the vectors between
    each contact and its K closest neighbors. vectors[k,i,:] contains the vector
    towards the k-th closest neighbor of contact i.
    """
    # Computing the distance map of the contacts
    # Generated by ChatGPT
    diff = contacts[:, np.newaxis, :] - contacts[np.newaxis, :, :]
    distance_map = np.sqrt(np.sum(diff**2, axis=-1))

    # a value that makes an entry of the distance map unpickable
    UNPICKABLE = distance_map.max()    

    # Sabotaging the diagonal so that a contact cannot be closest to itself
    n = contacts.shape[0]
    distance_map[range(n), range(n)] = UNPICKABLE

    # Computing the N closest contact to each contact
    # closest[i] is the coordinates of the contact that is closest to contact i
    neighbors = []
    for i in range(k):
        closest_indices = np.argmin(distance_map, axis=1)   # Shape (N,)
        neighbors.append(contacts[closest_indices])    # Shape (N, 3)
        distance_map[range(n), closest_indices] = UNPICKABLE


    neighbors = np.stack(neighbors)
    return neighbors, (np.stack(neighbors) - contacts[np.newaxis,:])


def __get_direction_neighbors(contacts: np.ndarray, k:int) -> np.ndarray:
    """TODO write documentation
    
    In: (N, 3)
    Out: (N, 3) but accounts for angle between closest, c and other neighbors (must be < 180Â°)"""
    _, vectors = __get_vector_K_nearest(contacts, k)

    if k <= 1:
        return vectors[0]
    
    # For each contact, flipping the neighbor vectors that go in a direction
    # opposite to the first neighbor vector. This is to ensure that all vectors
    # of each contact go in the same direction, and won't cancel each other out
    # when computing their average.
    # Generated by ChatGPT
    dot_products = np.sum(vectors*vectors[0], axis=2)  # Shape (K, N)
    flip_mask = dot_products < 0  # Shape (K, N)

    # Expand dimensions to match (K, N, 3)
    flip_mask = np.expand_dims(flip_mask, axis=2).repeat(3, axis=2)  # Shape (K, N, 3)
    vectors[flip_mask] = -vectors[flip_mask]
    
    return vectors.mean(axis=0)


def __feature_vector_closest(contacts: np.ndarray) -> np.ndarray:
    """Returns the vector that leads each contact to its closest contact.

    Input:
    - contacts: an array of shape (N, 3) that contains the coordinates of the N
    contacts.

    Output:
    - vector_posx: the array of shape (N, 3) that contains, for each contact, 
    the vector to its closest contact. Each vector is potentially flipped as
    to have a positive x-component."""

    # Computing the vector between each contact and its closest contact
    _, vector = __get_vector_K_nearest(contacts, k=1)[0]    # Shape (N, 3)

    # Adjusting the weight of this feature
    # and multiplying where needed to have a positive x component
    vector /= np.mean(np.linalg.norm(vector, axis=1))   # dividing by norm mean
    vector *= np.std(contacts, axis=0)
    vector_posx = __flip_positive_x(vector)

    return  vector_posx


def __feature_proj_circle(contacts):

    def __proj_circle(
            sc: np.ndarray, 
            sr: float,
            lo: np.ndarray,
            lu: np.ndarray
    ) -> np.ndarray:
        # Source: https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection
        lu = __flip_positive_x(lu) 
        lu1 = lu / norm(lu, axis=1)[:,np.newaxis]
        
        #delta = np.diag(lu1 @ (lo-sc).T)**2 - (norm(lo-sc, axis=1)**2 - sr**2)
        #sol = - np.diag(lu1 @ (lo-sc).T)**2 + np.sqrt(delta)


        a = norm(lu, axis=1)**2
        b = np.diag(2 * lu @ (lo-sc).T)   # only diag interests us
        c = norm(lo-sc, axis=1)**2 - sr**2

        # an array of shape (N,) that corresponds to the factor of each row in lu
        sol = (-2*b + np.sqrt(b**2 - 4*a*c)) / (2*a)

        # Projecting line onto circle
        # Broadcasting sol to convert shape (N,) into (N, 3)
        return lo + sol[:, np.newaxis] * lu
    
    # TODO remove test:
    sc = np.array([-2.5, 1.5, 2])
    sr = 9
    lo = np.array([[1,-1,3]])
    lu = np.array([
        [13,-1,22],
    ])

    sc = contacts.mean(axis=0)
    sr = 3 * contacts.std(axis=0).max()
    lo = contacts
    lu = __feature_vector_closest(contacts)

    return __proj_circle(sc, sr, lo, lu)


def __feature_proj_plane(contacts, xval=0, k=2):
    """TODO write documentation"""
    vector = __get_direction_neighbors(contacts, k)
    proj = contacts + (-(xval-contacts[:,:1])/vector[:,:1]) * vector
    return proj[:,1:]


def __feature_proj_plane_new(contacts, xval=0, k=3):
    """This function returns features for the given list of contacts
    coordinates. For each contact:
    - its k nearest neighbors within 'contacts' are fetched;
    - a line is estimated by linear regression on these k+1 coordinates
    (the contact itself and its k neighbors);
    - the coordinates (y_p, z_p) are fetched where the line intersects with the
    plane x = xval. These coordinates (y_p, z_p) are the features returned for
    the contact.

    Input:
    - contacts: an array of shape (N, 3) that contains the coordinates of the N
    contacts.

    Output:
    - intersections: an array of shape (N, 2) such that 'intersections[i]'
    contains the features of 'contacts[i]', which are computed as stated above.
    """
    def __get_dir_regression():
        neigh, _ = __get_vector_K_nearest(contacts, k)
        data = np.concatenate([neigh, contacts[np.newaxis,:]])
        intercepts = []
        dirs = []
        # Fitting one regression for each 
        for i in range(contacts.shape[0]):
            x = data[:,i,:1]
            y = data[:,i,1:]
            model = LinearRegression(fit_intercept=True)
            model.fit(x, y)
            intercepts.append(model.intercept_)
            dirs.append(model.coef_.ravel())
        return np.stack(intercepts), np.stack(dirs)

    intercepts, coefs = __get_dir_regression()
    return intercepts + xval * coefs



def __extract_features(
        contacts: np.ndarray, 
        feat_list: List[str] = ["coords"]
) -> np.ndarray:
    """From the coordinates of the contacts, extracts and returns the demanded 
    features used in the clustering technique.

    Input:
    - contacts: an array of shape (N, 3) that contains the coordinates of the N
    contacts to cluster.
    - feat_list: a list of the features to include in the output. The list of
    available feature names is given below.

    Output:
    - features: an array of shape (N, M) that contains the M features for each of
    the N contacts.
    
    Available features:
    - "coords": the coordinates of c 
    - "vect_closest": the vector from c to its closest contact, potentially 
    multiplied by -1 as to have a positive x component in the vector. 
    E.g. vectors (-1, 2, 3) and (1, -2, -3) are considered the same.
    - "proj_closest: projects the line between c and its closest neighbor on a
    big circle, and returns the coordinates of the projection"""
    features = []

    if "coords" in feat_list:
        f = contacts
        features.append(f)
    if "vect_closest" in feat_list:
        f = __feature_vector_closest(contacts)
        features.append(f)
    if "proj_closest_sphere" in feat_list:
        f = __feature_proj_circle(contacts)
        features.append(f)
    if "proj_plane" in feat_list:
        xval = contacts[:,0].min()
        f1 = __feature_proj_plane(contacts, xval, k=3)
        xval = contacts[:,0].max()
        f2 = __feature_proj_plane(contacts, xval, k=3)
        features.append(f1)
        features.append(f2)
    if "proj_plane_new" in feat_list:
        f1 = __feature_proj_plane_new(contacts, xval=contacts[:,0].min(), k=3)
        f2 = __feature_proj_plane_new(contacts, xval=contacts[:,0].max(), k=3)
        features.append(f1)
        features.append(f2)


    assert len(features) > 0, "At least one valid feature name must be given."
    return np.concatenate(features, axis=1)


def segment_electrodes(
        contacts: np.ndarray,
        n_electrodes: int, 
        ct_shape: tuple
) -> List[Electrode]:
    """Groups contacts into electrodes.
    
    Inputs:
    - contacts: an array of shape (N, 3) that contains the coordinates of the
    N contacts to group into electrodes.
    - n_electrodes: the number of electrodes to group the contacts.
    - ct_shape: a tuple of length 3 that contains the dimensions. It is used to
    determine the direction of the electrode (which end is the deepest, and
    which end is at the entry of the skull).
    
    Outputs:
    electrodes: a list of electrodes computed from the given contacts. The list
    is of length n_electrodes."""
    # Feature extraction
    feat_list = [
        #"coords", 
        #"vect_closest",
        #"proj_closest_sphere",
        #"proj_plane",
        "proj_plane_new"
    ]
    features = __extract_features(contacts, feat_list)

    # Applying KMeans to retrieve 'labels', an array of shape (N,) that
    # contains the label of each contact (label is in range [0, n_electrodes))
    # The label is the id of the electrode
    kmeans = KMeans(n_clusters=n_electrodes)
    labels = kmeans.fit_predict(features)

    # Constructing the electrodes one by one
    electrodes = []
    for e in range(n_electrodes):
        relevant_contacts = contacts[labels == e]
        electrodes.append(Electrode(relevant_contacts, ct_shape))

    return electrodes